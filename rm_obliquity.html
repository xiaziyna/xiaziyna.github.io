<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>RM Effect: True vs Projected Obliquity</title>
<style>
* { box-sizing: border-box; }
body { margin: 0; background: #111; color: #eee; font-family: system-ui; }
.container { display: flex; flex-wrap: wrap; padding: 20px; gap: 20px; }
.panel { background: #1a1a1a; border-radius: 8px; padding: 20px; }
.panel h2 { margin: 0 0 15px 0; font-size: 14px; color: #888; text-transform: uppercase; letter-spacing: 1px; }
canvas { background: #000; border-radius: 6px; display: block; }
.control { margin: 10px 0; }
.control label { display: block; margin-bottom: 4px; font-size: 13px; }
.control input[type="range"] { width: 100%; }
.value { float: right; font-family: monospace; color: #8af; }
.eq { background: #222; padding: 15px; border-radius: 6px; font-family: monospace; font-size: 14px; margin: 15px 0; }
.eq .result { color: #4f8; font-size: 18px; margin-top: 10px; }
.warning { color: #f84; font-size: 12px; margin-top: 5px; }
.ambig { background: #2a2020; border-left: 3px solid #f44; padding: 12px; margin: 15px 0; border-radius: 0 6px 6px 0; }
.legend { font-size: 12px; margin-top: 10px; }
.legend span { display: inline-block; margin-right: 15px; }
.legend .dot { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 4px; vertical-align: middle; }
</style>
</head>
<body>
<div class="container">

<div class="panel" style="width: 540px;">
  <h2>3D Geometry</h2>
  <canvas id="geom3d" width="500" height="400"></canvas>
  <div class="legend">
    <span><span class="dot" style="background:#4af;"></span> Stellar spin axis</span>
    <span><span class="dot" style="background:#f84;"></span> Orbital normal</span>
    <span><span class="dot" style="background:#8f4;"></span> Line of sight</span>
  </div>
</div>

<div class="panel" style="width: 320px;">
  <h2>Parameters</h2>

  <div class="control">
    <label>Projected Obliquity λ <span class="value" id="lambdaVal">30°</span></label>
    <input type="range" id="lambda" min="-180" max="180" value="30">
  </div>

  <div class="control">
    <label>Stellar Inclination i★ <span class="value" id="istarVal">90°</span></label>
    <input type="range" id="istar" min="5" max="90" value="90">
    <div class="warning" id="istarWarn"></div>
  </div>

  <div class="control">
    <label>Orbital Inclination i<sub>p</sub> <span class="value" id="iorbVal">90°</span></label>
    <input type="range" id="iorb" min="80" max="90" value="90">
  </div>

  <div class="eq">
    cos(ψ) = sin(i★)·sin(i<sub>p</sub>)·cos(λ) + cos(i★)·cos(i<sub>p</sub>)
    <div class="result">True obliquity ψ = <span id="psiResult">30.0°</span></div>
  </div>

  <div class="ambig" id="ambigNote">
    <b>The Degeneracy:</b><br>
    Same λ = 30° gives different ψ depending on unknown i★
  </div>
</div>

<div class="panel" style="width: 540px;">
  <h2>Degeneracy Map: λ vs i★ → ψ</h2>
  <canvas id="degMap" width="500" height="300"></canvas>
  <div style="font-size: 12px; color: #888; margin-top: 10px;">
    Contours show true obliquity ψ. Vertical line = your λ. The range of possible ψ depends on i★.
  </div>
</div>

<div class="panel" style="width: 320px;">
  <h2>What We Can Measure</h2>
  <div style="font-size: 13px; line-height: 1.6;">
    <b style="color:#4af;">From RM effect:</b> λ (projected angle)<br><br>

    <b style="color:#f84;">From spectroscopy:</b> v sin i★<br><br>

    <b style="color:#8f4;">From photometry:</b> P<sub>rot</sub> (if spots visible)<br>
    → Then v = 2πR★/P<sub>rot</sub><br>
    → And i★ = arcsin(v sin i★ / v)<br><br>

    <b style="color:#ff8;">From asteroseismology:</b> i★ directly<br>
    (requires bright star, long baseline)
  </div>

  <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #333;">
    <b>Without i★ constraint:</b><br>
    <span id="psiRange" style="color: #f84; font-size: 14px;"></span>
  </div>
</div>

</div>

<script>
const geomCanvas = document.getElementById('geom3d');
const degCanvas = document.getElementById('degMap');
const geomCtx = geomCanvas.getContext('2d');
const degCtx = degCanvas.getContext('2d');

const controls = {
  lambda: document.getElementById('lambda'),
  istar: document.getElementById('istar'),
  iorb: document.getElementById('iorb')
};

function rad(deg) { return deg * Math.PI / 180; }
function deg(rad) { return rad * 180 / Math.PI; }

function computePsi(lambda, istar, iorb) {
  const l = rad(lambda), is = rad(istar), io = rad(iorb);
  const cosPsi = Math.sin(is) * Math.sin(io) * Math.cos(l) + Math.cos(is) * Math.cos(io);
  return deg(Math.acos(Math.max(-1, Math.min(1, cosPsi))));
}

function project3D(x, y, z, rotY, rotX) {
  // Rotate around Y
  let x1 = x * Math.cos(rotY) + z * Math.sin(rotY);
  let z1 = -x * Math.sin(rotY) + z * Math.cos(rotY);
  let y1 = y;
  // Rotate around X
  let y2 = y1 * Math.cos(rotX) - z1 * Math.sin(rotX);
  let z2 = y1 * Math.sin(rotX) + z1 * Math.cos(rotX);
  // Simple projection
  const scale = 150;
  return { x: x1 * scale, y: -y2 * scale, z: z2 };
}

function drawArrow(ctx, x1, y1, x2, y2, color, label) {
  ctx.strokeStyle = color;
  ctx.fillStyle = color;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();

  // Arrowhead
  const angle = Math.atan2(y2 - y1, x2 - x1);
  const headLen = 10;
  ctx.beginPath();
  ctx.moveTo(x2, y2);
  ctx.lineTo(x2 - headLen * Math.cos(angle - 0.4), y2 - headLen * Math.sin(angle - 0.4));
  ctx.lineTo(x2 - headLen * Math.cos(angle + 0.4), y2 - headLen * Math.sin(angle + 0.4));
  ctx.closePath();
  ctx.fill();

  if (label) {
    ctx.font = '12px system-ui';
    ctx.fillText(label, x2 + 8, y2 + 4);
  }
}

function draw3D(ctx) {
  const w = geomCanvas.width, h = geomCanvas.height;
  const cx = w / 2, cy = h / 2;
  ctx.clearRect(0, 0, w, h);

  const lambda = +controls.lambda.value;
  const istar = +controls.istar.value;
  const iorb = +controls.iorb.value;

  const viewRotY = 0.5;
  const viewRotX = 0.3;

  // Draw reference sphere (faint)
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.arc(cx, cy, 120, 0, Math.PI * 2);
  ctx.stroke();

  // Line of sight (Z axis pointing at us)
  const los = project3D(0, 0, 1.3, viewRotY, viewRotX);
  drawArrow(ctx, cx, cy, cx + los.x, cy + los.y, '#8f4', 'LOS');

  // Sky plane axes (X and Y)
  ctx.strokeStyle = '#444';
  ctx.setLineDash([3, 3]);
  const skyX = project3D(1.2, 0, 0, viewRotY, viewRotX);
  const skyY = project3D(0, 1.2, 0, viewRotY, viewRotX);
  ctx.beginPath();
  ctx.moveTo(cx - skyX.x, cy - skyX.y);
  ctx.lineTo(cx + skyX.x, cy + skyX.y);
  ctx.moveTo(cx - skyY.x, cy - skyY.y);
  ctx.lineTo(cx + skyY.x, cy + skyY.y);
  ctx.stroke();
  ctx.setLineDash([]);

  // Stellar spin axis
  // Inclined by i★ from LOS, with λ rotation in sky plane
  const isRad = rad(istar);
  const lRad = rad(lambda);
  const spinX = Math.sin(isRad) * Math.sin(lRad);
  const spinY = Math.sin(isRad) * Math.cos(lRad);
  const spinZ = Math.cos(isRad);
  const spin = project3D(spinX * 1.1, spinY * 1.1, spinZ * 1.1, viewRotY, viewRotX);
  drawArrow(ctx, cx, cy, cx + spin.x, cy + spin.y, '#4af', 'S★');

  // Orbital normal (inclined by i_orb from LOS, in Y-Z plane for simplicity)
  const ioRad = rad(iorb);
  const orbX = 0;
  const orbY = Math.sin(Math.PI/2 - ioRad);
  const orbZ = Math.cos(Math.PI/2 - ioRad);
  const orb = project3D(orbX * 1.1, orbY * 1.1, orbZ * 1.1, viewRotY, viewRotX);
  drawArrow(ctx, cx, cy, cx + orb.x, cy + orb.y, '#f84', 'L_orb');

  // Draw angle arc for ψ
  const psi = computePsi(lambda, istar, iorb);
  ctx.strokeStyle = '#ff8';
  ctx.lineWidth = 2;
  const arcR = 50;
  // Draw arc between spin and orbital axes
  ctx.beginPath();
  const steps = 20;
  for (let i = 0; i <= steps; i++) {
    const t = i / steps;
    const ax = spinX * (1-t) + orbX * t;
    const ay = spinY * (1-t) + orbY * t;
    const az = spinZ * (1-t) + orbZ * t;
    const len = Math.sqrt(ax*ax + ay*ay + az*az);
    const p = project3D(ax/len * 0.4, ay/len * 0.4, az/len * 0.4, viewRotY, viewRotX);
    if (i === 0) ctx.moveTo(cx + p.x, cy + p.y);
    else ctx.lineTo(cx + p.x, cy + p.y);
  }
  ctx.stroke();

  // Label ψ
  const midX = (spinX + orbX) / 2, midY = (spinY + orbY) / 2, midZ = (spinZ + orbZ) / 2;
  const midLen = Math.sqrt(midX*midX + midY*midY + midZ*midZ);
  const midP = project3D(midX/midLen * 0.5, midY/midLen * 0.5, midZ/midLen * 0.5, viewRotY, viewRotX);
  ctx.fillStyle = '#ff8';
  ctx.font = '14px system-ui';
  ctx.fillText('ψ=' + psi.toFixed(0) + '°', cx + midP.x + 10, cy + midP.y);

  // Draw projected λ on sky plane
  ctx.strokeStyle = '#4af4';
  ctx.lineWidth = 1;
  ctx.setLineDash([5, 3]);
  const projSpin = project3D(spinX, spinY, 0, viewRotY, viewRotX);
  ctx.beginPath();
  ctx.moveTo(cx, cy);
  ctx.lineTo(cx + projSpin.x * 0.7, cy + projSpin.y * 0.7);
  ctx.stroke();
  ctx.setLineDash([]);

  // Label λ
  ctx.fillStyle = '#4af';
  ctx.fillText('λ=' + lambda + '°', cx + projSpin.x * 0.4 + 10, cy + projSpin.y * 0.4);
}

function drawDegeneracyMap(ctx) {
  const w = degCanvas.width, h = degCanvas.height;
  ctx.clearRect(0, 0, w, h);

  const lambda = +controls.lambda.value;
  const iorb = +controls.iorb.value;

  // Create heatmap: x = λ, y = i★, color = ψ
  const imgData = ctx.createImageData(w, h);
  const data = imgData.data;

  for (let py = 0; py < h; py++) {
    for (let px = 0; px < w; px++) {
      const l = (px / w) * 360 - 180; // -180 to 180
      const is = 90 - (py / h) * 85; // 90 to 5 (top to bottom)
      const psi = computePsi(l, is, iorb);

      // Color by ψ: 0=green, 90=yellow, 180=red
      const t = psi / 180;
      const r = Math.floor(255 * Math.min(1, t * 2));
      const g = Math.floor(255 * Math.min(1, (1 - t) * 2));
      const b = 50;

      const idx = (py * w + px) * 4;
      data[idx] = r;
      data[idx + 1] = g;
      data[idx + 2] = b;
      data[idx + 3] = 200;
    }
  }
  ctx.putImageData(imgData, 0, 0);

  // Draw contours
  ctx.strokeStyle = '#fff4';
  ctx.lineWidth = 1;
  for (let psiTarget of [30, 60, 90, 120, 150]) {
    ctx.beginPath();
    let started = false;
    for (let px = 0; px < w; px++) {
      const l = (px / w) * 360 - 180;
      // Find i★ that gives this ψ
      for (let py = 0; py < h; py++) {
        const is = 90 - (py / h) * 85;
        const psi = computePsi(l, is, iorb);
        if (Math.abs(psi - psiTarget) < 1.5) {
          if (!started) { ctx.moveTo(px, py); started = true; }
          else ctx.lineTo(px, py);
          break;
        }
      }
    }
    ctx.stroke();
    // Label
    const labelX = w * (psiTarget < 90 ? 0.85 : 0.15);
    ctx.fillStyle = '#fff8';
    ctx.font = '10px system-ui';
  }

  // Current λ line
  const lx = (lambda + 180) / 360 * w;
  ctx.strokeStyle = '#4af';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(lx, 0);
  ctx.lineTo(lx, h);
  ctx.stroke();

  // Current i★ marker
  const istar = +controls.istar.value;
  const iy = (90 - istar) / 85 * h;
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(lx, iy, 6, 0, Math.PI * 2);
  ctx.fill();

  // Axis labels
  ctx.fillStyle = '#888';
  ctx.font = '11px system-ui';
  ctx.fillText('λ = -180°', 5, h - 5);
  ctx.fillText('λ = 0°', w/2 - 15, h - 5);
  ctx.fillText('λ = 180°', w - 50, h - 5);
  ctx.fillText('i★ = 90°', 5, 12);
  ctx.fillText('i★ = 5°', 5, h - 15);

  // Color legend
  ctx.fillStyle = '#0f0'; ctx.fillRect(w - 80, 10, 10, 10);
  ctx.fillStyle = '#ff0'; ctx.fillRect(w - 80, 25, 10, 10);
  ctx.fillStyle = '#f00'; ctx.fillRect(w - 80, 40, 10, 10);
  ctx.fillStyle = '#aaa';
  ctx.fillText('ψ=0°', w - 65, 19);
  ctx.fillText('ψ=90°', w - 65, 34);
  ctx.fillText('ψ=180°', w - 65, 49);
}

function updateAll() {
  const lambda = +controls.lambda.value;
  const istar = +controls.istar.value;
  const iorb = +controls.iorb.value;

  document.getElementById('lambdaVal').textContent = lambda + '°';
  document.getElementById('istarVal').textContent = istar + '°';
  document.getElementById('iorbVal').textContent = iorb + '°';

  const psi = computePsi(lambda, istar, iorb);
  document.getElementById('psiResult').textContent = psi.toFixed(1) + '°';

  // Warning for low i★
  const warn = document.getElementById('istarWarn');
  if (istar < 30) {
    warn.textContent = '⚠ Low i★ often poorly constrained';
  } else {
    warn.textContent = '';
  }

  // Compute range of possible ψ for this λ
  let minPsi = 180, maxPsi = 0;
  for (let is = 5; is <= 90; is++) {
    const p = computePsi(lambda, is, iorb);
    minPsi = Math.min(minPsi, p);
    maxPsi = Math.max(maxPsi, p);
  }
  document.getElementById('psiRange').textContent =
    `ψ could be ${minPsi.toFixed(0)}° to ${maxPsi.toFixed(0)}°`;

  document.getElementById('ambigNote').innerHTML =
    `<b>The Degeneracy:</b><br>λ = ${lambda}° measured, but true ψ = ${psi.toFixed(0)}° only if i★ = ${istar}°`;

  draw3D(geomCtx);
  drawDegeneracyMap(degCtx);
}

Object.values(controls).forEach(c => c.addEventListener('input', updateAll));
updateAll();
</script>
</body>
</html>
